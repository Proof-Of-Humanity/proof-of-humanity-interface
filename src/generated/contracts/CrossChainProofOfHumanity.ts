/* Autogenerated file. Do not edit manually. */

/* tslint:disable */

/* eslint-disable */
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";

export interface CrossChainProofOfHumanityInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "addBridgeGateway"
      | "bridgeGateways"
      | "changeGovernor"
      | "changeProofOfHumanity"
      | "governor"
      | "humanityMapping"
      | "humans"
      | "initialize"
      | "initialized"
      | "isClaimed"
      | "isHuman"
      | "proofOfHumanity"
      | "receiveTransfer"
      | "receiveUpdate"
      | "receivedTransferHashes"
      | "removeBridgeGateway"
      | "retryFailedTransfer"
      | "setTransferCooldown"
      | "transferCooldown"
      | "transferHumanity"
      | "transfers"
      | "updateHumanity"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "GatewayAdded"
      | "GatewayRemoved"
      | "TransferInitiated"
      | "TransferReceived"
      | "TransferRetry"
      | "UpdateInitiated"
      | "UpdateReceived"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "addBridgeGateway",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "bridgeGateways",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "changeGovernor",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "changeProofOfHumanity",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "governor", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "humanityMapping",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "humans", values: [AddressLike]): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initialized",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isClaimed",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isHuman",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "proofOfHumanity",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "receiveTransfer",
    values: [AddressLike, BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "receiveUpdate",
    values: [AddressLike, BytesLike, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "receivedTransferHashes",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "removeBridgeGateway",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "retryFailedTransfer",
    values: [BytesLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setTransferCooldown",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferCooldown",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferHumanity",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transfers",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "updateHumanity",
    values: [AddressLike, BytesLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "addBridgeGateway",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bridgeGateways",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeGovernor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeProofOfHumanity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "governor", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "humanityMapping",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "humans", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "initialized",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isClaimed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isHuman", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proofOfHumanity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "receiveTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "receiveUpdate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "receivedTransferHashes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeBridgeGateway",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "retryFailedTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTransferCooldown",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferCooldown",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferHumanity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "transfers", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateHumanity",
    data: BytesLike
  ): Result;
}

export namespace GatewayAddedEvent {
  export type InputTuple = [
    bridgeGateway: AddressLike,
    foreignProxy: AddressLike
  ];
  export type OutputTuple = [bridgeGateway: string, foreignProxy: string];
  export interface OutputObject {
    bridgeGateway: string;
    foreignProxy: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace GatewayRemovedEvent {
  export type InputTuple = [bridgeGateway: AddressLike];
  export type OutputTuple = [bridgeGateway: string];
  export interface OutputObject {
    bridgeGateway: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferInitiatedEvent {
  export type InputTuple = [
    humanityId: BytesLike,
    owner: AddressLike,
    expirationTime: BigNumberish,
    gateway: AddressLike,
    transferHash: BytesLike
  ];
  export type OutputTuple = [
    humanityId: string,
    owner: string,
    expirationTime: bigint,
    gateway: string,
    transferHash: string
  ];
  export interface OutputObject {
    humanityId: string;
    owner: string;
    expirationTime: bigint;
    gateway: string;
    transferHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferReceivedEvent {
  export type InputTuple = [
    humanityId: BytesLike,
    owner: AddressLike,
    expirationTime: BigNumberish,
    transferHash: BytesLike
  ];
  export type OutputTuple = [
    humanityId: string,
    owner: string,
    expirationTime: bigint,
    transferHash: string
  ];
  export interface OutputObject {
    humanityId: string;
    owner: string;
    expirationTime: bigint;
    transferHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferRetryEvent {
  export type InputTuple = [transferHash: BytesLike];
  export type OutputTuple = [transferHash: string];
  export interface OutputObject {
    transferHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UpdateInitiatedEvent {
  export type InputTuple = [
    humanityId: BytesLike,
    owner: AddressLike,
    expirationTime: BigNumberish,
    gateway: AddressLike,
    claimed: boolean
  ];
  export type OutputTuple = [
    humanityId: string,
    owner: string,
    expirationTime: bigint,
    gateway: string,
    claimed: boolean
  ];
  export interface OutputObject {
    humanityId: string;
    owner: string;
    expirationTime: bigint;
    gateway: string;
    claimed: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UpdateReceivedEvent {
  export type InputTuple = [
    humanityId: BytesLike,
    owner: AddressLike,
    expirationTime: BigNumberish,
    claimed: boolean
  ];
  export type OutputTuple = [
    humanityId: string,
    owner: string,
    expirationTime: bigint,
    claimed: boolean
  ];
  export interface OutputObject {
    humanityId: string;
    owner: string;
    expirationTime: bigint;
    claimed: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface CrossChainProofOfHumanity extends BaseContract {
  connect(runner?: ContractRunner | null): BaseContract;
  attach(addressOrName: AddressLike): this;
  deployed(): Promise<this>;

  interface: CrossChainProofOfHumanityInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  addBridgeGateway: TypedContractMethod<
    [_bridgeGateway: AddressLike, _foreignProxy: AddressLike],
    [void],
    "nonpayable"
  >;

  bridgeGateways: TypedContractMethod<
    [arg0: AddressLike],
    [[string, boolean] & { foreignProxy: string; approved: boolean }],
    "view"
  >;

  changeGovernor: TypedContractMethod<
    [_governor: AddressLike],
    [void],
    "nonpayable"
  >;

  changeProofOfHumanity: TypedContractMethod<
    [_proofOfHumanity: AddressLike],
    [void],
    "nonpayable"
  >;

  governor: TypedContractMethod<[], [string], "view">;

  humanityMapping: TypedContractMethod<
    [arg0: BytesLike],
    [
      [boolean, bigint, string, bigint] & {
        isHomeChain: boolean;
        expirationTime: bigint;
        owner: string;
        lastTransferTime: bigint;
      }
    ],
    "view"
  >;

  humans: TypedContractMethod<[arg0: AddressLike], [string], "view">;

  initialize: TypedContractMethod<
    [_proofOfHumanity: AddressLike, _transferCooldown: BigNumberish],
    [void],
    "nonpayable"
  >;

  initialized: TypedContractMethod<[], [boolean], "view">;

  isClaimed: TypedContractMethod<[_humanityId: BytesLike], [boolean], "view">;

  isHuman: TypedContractMethod<[_owner: AddressLike], [boolean], "view">;

  proofOfHumanity: TypedContractMethod<[], [string], "view">;

  receiveTransfer: TypedContractMethod<
    [
      _owner: AddressLike,
      _humanityId: BytesLike,
      _expirationTime: BigNumberish,
      _transferHash: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  receiveUpdate: TypedContractMethod<
    [
      _owner: AddressLike,
      _humanityId: BytesLike,
      _expirationTime: BigNumberish,
      _isActive: boolean
    ],
    [void],
    "nonpayable"
  >;

  receivedTransferHashes: TypedContractMethod<
    [arg0: BytesLike],
    [boolean],
    "view"
  >;

  removeBridgeGateway: TypedContractMethod<
    [_bridgeGateway: AddressLike],
    [void],
    "nonpayable"
  >;

  retryFailedTransfer: TypedContractMethod<
    [_humanityId: BytesLike, _bridgeGateway: AddressLike],
    [void],
    "nonpayable"
  >;

  setTransferCooldown: TypedContractMethod<
    [_transferCooldown: BigNumberish],
    [void],
    "nonpayable"
  >;

  transferCooldown: TypedContractMethod<[], [bigint], "view">;

  transferHumanity: TypedContractMethod<
    [_bridgeGateway: AddressLike],
    [void],
    "nonpayable"
  >;

  transfers: TypedContractMethod<
    [arg0: BytesLike],
    [
      [string, bigint, string, string] & {
        humanityId: string;
        humanityExpirationTime: bigint;
        transferHash: string;
        foreignProxy: string;
      }
    ],
    "view"
  >;

  updateHumanity: TypedContractMethod<
    [_bridgeGateway: AddressLike, _humanityId: BytesLike],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "addBridgeGateway"
  ): TypedContractMethod<
    [_bridgeGateway: AddressLike, _foreignProxy: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "bridgeGateways"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [[string, boolean] & { foreignProxy: string; approved: boolean }],
    "view"
  >;
  getFunction(
    nameOrSignature: "changeGovernor"
  ): TypedContractMethod<[_governor: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "changeProofOfHumanity"
  ): TypedContractMethod<[_proofOfHumanity: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "governor"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "humanityMapping"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [boolean, bigint, string, bigint] & {
        isHomeChain: boolean;
        expirationTime: bigint;
        owner: string;
        lastTransferTime: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "humans"
  ): TypedContractMethod<[arg0: AddressLike], [string], "view">;
  getFunction(
    nameOrSignature: "initialize"
  ): TypedContractMethod<
    [_proofOfHumanity: AddressLike, _transferCooldown: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "initialized"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "isClaimed"
  ): TypedContractMethod<[_humanityId: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "isHuman"
  ): TypedContractMethod<[_owner: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "proofOfHumanity"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "receiveTransfer"
  ): TypedContractMethod<
    [
      _owner: AddressLike,
      _humanityId: BytesLike,
      _expirationTime: BigNumberish,
      _transferHash: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "receiveUpdate"
  ): TypedContractMethod<
    [
      _owner: AddressLike,
      _humanityId: BytesLike,
      _expirationTime: BigNumberish,
      _isActive: boolean
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "receivedTransferHashes"
  ): TypedContractMethod<[arg0: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "removeBridgeGateway"
  ): TypedContractMethod<[_bridgeGateway: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "retryFailedTransfer"
  ): TypedContractMethod<
    [_humanityId: BytesLike, _bridgeGateway: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setTransferCooldown"
  ): TypedContractMethod<
    [_transferCooldown: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferCooldown"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "transferHumanity"
  ): TypedContractMethod<[_bridgeGateway: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "transfers"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [string, bigint, string, string] & {
        humanityId: string;
        humanityExpirationTime: bigint;
        transferHash: string;
        foreignProxy: string;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "updateHumanity"
  ): TypedContractMethod<
    [_bridgeGateway: AddressLike, _humanityId: BytesLike],
    [void],
    "nonpayable"
  >;

  getEvent(
    key: "GatewayAdded"
  ): TypedContractEvent<
    GatewayAddedEvent.InputTuple,
    GatewayAddedEvent.OutputTuple,
    GatewayAddedEvent.OutputObject
  >;
  getEvent(
    key: "GatewayRemoved"
  ): TypedContractEvent<
    GatewayRemovedEvent.InputTuple,
    GatewayRemovedEvent.OutputTuple,
    GatewayRemovedEvent.OutputObject
  >;
  getEvent(
    key: "TransferInitiated"
  ): TypedContractEvent<
    TransferInitiatedEvent.InputTuple,
    TransferInitiatedEvent.OutputTuple,
    TransferInitiatedEvent.OutputObject
  >;
  getEvent(
    key: "TransferReceived"
  ): TypedContractEvent<
    TransferReceivedEvent.InputTuple,
    TransferReceivedEvent.OutputTuple,
    TransferReceivedEvent.OutputObject
  >;
  getEvent(
    key: "TransferRetry"
  ): TypedContractEvent<
    TransferRetryEvent.InputTuple,
    TransferRetryEvent.OutputTuple,
    TransferRetryEvent.OutputObject
  >;
  getEvent(
    key: "UpdateInitiated"
  ): TypedContractEvent<
    UpdateInitiatedEvent.InputTuple,
    UpdateInitiatedEvent.OutputTuple,
    UpdateInitiatedEvent.OutputObject
  >;
  getEvent(
    key: "UpdateReceived"
  ): TypedContractEvent<
    UpdateReceivedEvent.InputTuple,
    UpdateReceivedEvent.OutputTuple,
    UpdateReceivedEvent.OutputObject
  >;

  filters: {
    "GatewayAdded(address,address)": TypedContractEvent<
      GatewayAddedEvent.InputTuple,
      GatewayAddedEvent.OutputTuple,
      GatewayAddedEvent.OutputObject
    >;
    GatewayAdded: TypedContractEvent<
      GatewayAddedEvent.InputTuple,
      GatewayAddedEvent.OutputTuple,
      GatewayAddedEvent.OutputObject
    >;

    "GatewayRemoved(address)": TypedContractEvent<
      GatewayRemovedEvent.InputTuple,
      GatewayRemovedEvent.OutputTuple,
      GatewayRemovedEvent.OutputObject
    >;
    GatewayRemoved: TypedContractEvent<
      GatewayRemovedEvent.InputTuple,
      GatewayRemovedEvent.OutputTuple,
      GatewayRemovedEvent.OutputObject
    >;

    "TransferInitiated(bytes20,address,uint160,address,bytes32)": TypedContractEvent<
      TransferInitiatedEvent.InputTuple,
      TransferInitiatedEvent.OutputTuple,
      TransferInitiatedEvent.OutputObject
    >;
    TransferInitiated: TypedContractEvent<
      TransferInitiatedEvent.InputTuple,
      TransferInitiatedEvent.OutputTuple,
      TransferInitiatedEvent.OutputObject
    >;

    "TransferReceived(bytes20,address,uint160,bytes32)": TypedContractEvent<
      TransferReceivedEvent.InputTuple,
      TransferReceivedEvent.OutputTuple,
      TransferReceivedEvent.OutputObject
    >;
    TransferReceived: TypedContractEvent<
      TransferReceivedEvent.InputTuple,
      TransferReceivedEvent.OutputTuple,
      TransferReceivedEvent.OutputObject
    >;

    "TransferRetry(bytes32)": TypedContractEvent<
      TransferRetryEvent.InputTuple,
      TransferRetryEvent.OutputTuple,
      TransferRetryEvent.OutputObject
    >;
    TransferRetry: TypedContractEvent<
      TransferRetryEvent.InputTuple,
      TransferRetryEvent.OutputTuple,
      TransferRetryEvent.OutputObject
    >;

    "UpdateInitiated(bytes20,address,uint160,address,bool)": TypedContractEvent<
      UpdateInitiatedEvent.InputTuple,
      UpdateInitiatedEvent.OutputTuple,
      UpdateInitiatedEvent.OutputObject
    >;
    UpdateInitiated: TypedContractEvent<
      UpdateInitiatedEvent.InputTuple,
      UpdateInitiatedEvent.OutputTuple,
      UpdateInitiatedEvent.OutputObject
    >;

    "UpdateReceived(bytes20,address,uint160,bool)": TypedContractEvent<
      UpdateReceivedEvent.InputTuple,
      UpdateReceivedEvent.OutputTuple,
      UpdateReceivedEvent.OutputObject
    >;
    UpdateReceived: TypedContractEvent<
      UpdateReceivedEvent.InputTuple,
      UpdateReceivedEvent.OutputTuple,
      UpdateReceivedEvent.OutputObject
    >;
  };
}
