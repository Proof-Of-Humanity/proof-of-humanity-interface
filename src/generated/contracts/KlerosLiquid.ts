/* Autogenerated file. Do not edit manually. */

/* tslint:disable */

/* eslint-disable */
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";

export interface KlerosLiquidInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "changePinakion"
      | "RNBlock"
      | "disputesWithoutJurors"
      | "passPhase"
      | "governor"
      | "lastDelayedSetStake"
      | "disputeStatus"
      | "passPeriod"
      | "maxDrawingTime"
      | "currentRuling"
      | "courts"
      | "execute"
      | "ALPHA_DIVISOR"
      | "castVote"
      | "changeSubcourtMinStake"
      | "getSubcourt"
      | "appeal"
      | "onTransfer"
      | "disputes"
      | "changeSubcourtTimesPerPeriod"
      | "changeSubcourtJurorFee"
      | "changeSubcourtAlpha"
      | "castCommit"
      | "RN"
      | "RNGenerator"
      | "executeGovernorProposal"
      | "changeMinStakingTime"
      | "NON_PAYABLE_AMOUNT"
      | "setStake"
      | "executeRuling"
      | "getVote"
      | "changeRNGenerator"
      | "executeDelayedSetStakes"
      | "stakeOf"
      | "changeSubcourtJurorsForJump"
      | "appealPeriod"
      | "phase"
      | "MAX_STAKE_PATHS"
      | "delayedSetStakes"
      | "lastPhaseChange"
      | "minStakingTime"
      | "nextDelayedSetStake"
      | "createDispute"
      | "drawJurors"
      | "createSubcourt"
      | "getJuror"
      | "onApprove"
      | "jurors"
      | "changeMaxDrawingTime"
      | "getDispute"
      | "getVoteCounter"
      | "changeGovernor"
      | "MIN_JURORS"
      | "appealCost"
      | "proxyPayment"
      | "lockInsolventTransfers"
      | "arbitrationCost"
      | "pinakion"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "NewPhase"
      | "NewPeriod"
      | "StakeSet"
      | "Draw"
      | "TokenAndETHShift"
      | "DisputeCreation"
      | "AppealPossible"
      | "AppealDecision"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "changePinakion",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "RNBlock", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "disputesWithoutJurors",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "passPhase", values?: undefined): string;
  encodeFunctionData(functionFragment: "governor", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "lastDelayedSetStake",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "disputeStatus",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "passPeriod",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "maxDrawingTime",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "currentRuling",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "courts",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "execute",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "ALPHA_DIVISOR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "castVote",
    values: [BigNumberish, BigNumberish[], BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "changeSubcourtMinStake",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getSubcourt",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "appeal",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "onTransfer",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "disputes",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "changeSubcourtTimesPerPeriod",
    values: [
      BigNumberish,
      [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "changeSubcourtJurorFee",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "changeSubcourtAlpha",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "castCommit",
    values: [BigNumberish, BigNumberish[], BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "RN", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "RNGenerator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "executeGovernorProposal",
    values: [AddressLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "changeMinStakingTime",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "NON_PAYABLE_AMOUNT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setStake",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executeRuling",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getVote",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "changeRNGenerator",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "executeDelayedSetStakes",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "stakeOf",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "changeSubcourtJurorsForJump",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "appealPeriod",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "phase", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "MAX_STAKE_PATHS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "delayedSetStakes",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "lastPhaseChange",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minStakingTime",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nextDelayedSetStake",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "createDispute",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "drawJurors",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createSubcourt",
    values: [
      BigNumberish,
      boolean,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getJuror",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "onApprove",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "jurors", values: [AddressLike]): string;
  encodeFunctionData(
    functionFragment: "changeMaxDrawingTime",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getDispute",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getVoteCounter",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "changeGovernor",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_JURORS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "appealCost",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "proxyPayment",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "lockInsolventTransfers",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "arbitrationCost",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "pinakion", values?: undefined): string;

  decodeFunctionResult(
    functionFragment: "changePinakion",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "RNBlock", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "disputesWithoutJurors",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "passPhase", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "governor", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "lastDelayedSetStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disputeStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "passPeriod", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "maxDrawingTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentRuling",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "courts", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "execute", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "ALPHA_DIVISOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "castVote", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeSubcourtMinStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSubcourt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "appeal", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "onTransfer", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "disputes", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeSubcourtTimesPerPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeSubcourtJurorFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeSubcourtAlpha",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "castCommit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "RN", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "RNGenerator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeGovernorProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeMinStakingTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "NON_PAYABLE_AMOUNT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setStake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executeRuling",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getVote", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeRNGenerator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeDelayedSetStakes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "stakeOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeSubcourtJurorsForJump",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "appealPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "phase", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "MAX_STAKE_PATHS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "delayedSetStakes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastPhaseChange",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minStakingTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nextDelayedSetStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createDispute",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "drawJurors", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createSubcourt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getJuror", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "onApprove", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "jurors", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeMaxDrawingTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getDispute", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getVoteCounter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeGovernor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "MIN_JURORS", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "appealCost", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proxyPayment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lockInsolventTransfers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "arbitrationCost",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pinakion", data: BytesLike): Result;
}

export namespace NewPhaseEvent {
  export type InputTuple = [_phase: BigNumberish];
  export type OutputTuple = [_phase: bigint];
  export interface OutputObject {
    _phase: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NewPeriodEvent {
  export type InputTuple = [_disputeID: BigNumberish, _period: BigNumberish];
  export type OutputTuple = [_disputeID: bigint, _period: bigint];
  export interface OutputObject {
    _disputeID: bigint;
    _period: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace StakeSetEvent {
  export type InputTuple = [
    _address: AddressLike,
    _subcourtID: BigNumberish,
    _stake: BigNumberish,
    _newTotalStake: BigNumberish
  ];
  export type OutputTuple = [
    _address: string,
    _subcourtID: bigint,
    _stake: bigint,
    _newTotalStake: bigint
  ];
  export interface OutputObject {
    _address: string;
    _subcourtID: bigint;
    _stake: bigint;
    _newTotalStake: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DrawEvent {
  export type InputTuple = [
    _address: AddressLike,
    _disputeID: BigNumberish,
    _appeal: BigNumberish,
    _voteID: BigNumberish
  ];
  export type OutputTuple = [
    _address: string,
    _disputeID: bigint,
    _appeal: bigint,
    _voteID: bigint
  ];
  export interface OutputObject {
    _address: string;
    _disputeID: bigint;
    _appeal: bigint;
    _voteID: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TokenAndETHShiftEvent {
  export type InputTuple = [
    _address: AddressLike,
    _disputeID: BigNumberish,
    _tokenAmount: BigNumberish,
    _ETHAmount: BigNumberish
  ];
  export type OutputTuple = [
    _address: string,
    _disputeID: bigint,
    _tokenAmount: bigint,
    _ETHAmount: bigint
  ];
  export interface OutputObject {
    _address: string;
    _disputeID: bigint;
    _tokenAmount: bigint;
    _ETHAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DisputeCreationEvent {
  export type InputTuple = [_disputeID: BigNumberish, _arbitrable: AddressLike];
  export type OutputTuple = [_disputeID: bigint, _arbitrable: string];
  export interface OutputObject {
    _disputeID: bigint;
    _arbitrable: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace AppealPossibleEvent {
  export type InputTuple = [_disputeID: BigNumberish, _arbitrable: AddressLike];
  export type OutputTuple = [_disputeID: bigint, _arbitrable: string];
  export interface OutputObject {
    _disputeID: bigint;
    _arbitrable: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace AppealDecisionEvent {
  export type InputTuple = [_disputeID: BigNumberish, _arbitrable: AddressLike];
  export type OutputTuple = [_disputeID: bigint, _arbitrable: string];
  export interface OutputObject {
    _disputeID: bigint;
    _arbitrable: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface KlerosLiquid extends BaseContract {
  connect(runner?: ContractRunner | null): BaseContract;
  attach(addressOrName: AddressLike): this;
  deployed(): Promise<this>;

  interface: KlerosLiquidInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  changePinakion: TypedContractMethod<
    [_pinakion: AddressLike],
    [void],
    "nonpayable"
  >;

  RNBlock: TypedContractMethod<[], [bigint], "view">;

  disputesWithoutJurors: TypedContractMethod<[], [bigint], "view">;

  passPhase: TypedContractMethod<[], [void], "nonpayable">;

  governor: TypedContractMethod<[], [string], "view">;

  lastDelayedSetStake: TypedContractMethod<[], [bigint], "view">;

  disputeStatus: TypedContractMethod<
    [_disputeID: BigNumberish],
    [bigint],
    "view"
  >;

  passPeriod: TypedContractMethod<
    [_disputeID: BigNumberish],
    [void],
    "nonpayable"
  >;

  maxDrawingTime: TypedContractMethod<[], [bigint], "view">;

  currentRuling: TypedContractMethod<
    [_disputeID: BigNumberish],
    [bigint],
    "view"
  >;

  courts: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, boolean, bigint, bigint, bigint, bigint] & {
        parent: bigint;
        hiddenVotes: boolean;
        minStake: bigint;
        alpha: bigint;
        feeForJuror: bigint;
        jurorsForCourtJump: bigint;
      }
    ],
    "view"
  >;

  execute: TypedContractMethod<
    [
      _disputeID: BigNumberish,
      _appeal: BigNumberish,
      _iterations: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  ALPHA_DIVISOR: TypedContractMethod<[], [bigint], "view">;

  castVote: TypedContractMethod<
    [
      _disputeID: BigNumberish,
      _voteIDs: BigNumberish[],
      _choice: BigNumberish,
      _salt: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  changeSubcourtMinStake: TypedContractMethod<
    [_subcourtID: BigNumberish, _minStake: BigNumberish],
    [void],
    "nonpayable"
  >;

  getSubcourt: TypedContractMethod<
    [_subcourtID: BigNumberish],
    [
      [bigint[], [bigint, bigint, bigint, bigint]] & {
        children: bigint[];
        timesPerPeriod: [bigint, bigint, bigint, bigint];
      }
    ],
    "view"
  >;

  appeal: TypedContractMethod<
    [_disputeID: BigNumberish, _extraData: BytesLike],
    [void],
    "payable"
  >;

  onTransfer: TypedContractMethod<
    [_from: AddressLike, _to: AddressLike, _amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  disputes: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, string, bigint, bigint, bigint, bigint, bigint, boolean] & {
        subcourtID: bigint;
        arbitrated: string;
        numberOfChoices: bigint;
        period: bigint;
        lastPeriodChange: bigint;
        drawsInRound: bigint;
        commitsInRound: bigint;
        ruled: boolean;
      }
    ],
    "view"
  >;

  changeSubcourtTimesPerPeriod: TypedContractMethod<
    [
      _subcourtID: BigNumberish,
      _timesPerPeriod: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
    ],
    [void],
    "nonpayable"
  >;

  changeSubcourtJurorFee: TypedContractMethod<
    [_subcourtID: BigNumberish, _feeForJuror: BigNumberish],
    [void],
    "nonpayable"
  >;

  changeSubcourtAlpha: TypedContractMethod<
    [_subcourtID: BigNumberish, _alpha: BigNumberish],
    [void],
    "nonpayable"
  >;

  castCommit: TypedContractMethod<
    [_disputeID: BigNumberish, _voteIDs: BigNumberish[], _commit: BytesLike],
    [void],
    "nonpayable"
  >;

  RN: TypedContractMethod<[], [bigint], "view">;

  RNGenerator: TypedContractMethod<[], [string], "view">;

  executeGovernorProposal: TypedContractMethod<
    [_destination: AddressLike, _amount: BigNumberish, _data: BytesLike],
    [void],
    "nonpayable"
  >;

  changeMinStakingTime: TypedContractMethod<
    [_minStakingTime: BigNumberish],
    [void],
    "nonpayable"
  >;

  NON_PAYABLE_AMOUNT: TypedContractMethod<[], [bigint], "view">;

  setStake: TypedContractMethod<
    [_subcourtID: BigNumberish, _stake: BigNumberish],
    [void],
    "nonpayable"
  >;

  executeRuling: TypedContractMethod<
    [_disputeID: BigNumberish],
    [void],
    "nonpayable"
  >;

  getVote: TypedContractMethod<
    [_disputeID: BigNumberish, _appeal: BigNumberish, _voteID: BigNumberish],
    [
      [string, string, bigint, boolean] & {
        account: string;
        commit: string;
        choice: bigint;
        voted: boolean;
      }
    ],
    "view"
  >;

  changeRNGenerator: TypedContractMethod<
    [_RNGenerator: AddressLike],
    [void],
    "nonpayable"
  >;

  executeDelayedSetStakes: TypedContractMethod<
    [_iterations: BigNumberish],
    [void],
    "nonpayable"
  >;

  stakeOf: TypedContractMethod<
    [_account: AddressLike, _subcourtID: BigNumberish],
    [bigint],
    "view"
  >;

  changeSubcourtJurorsForJump: TypedContractMethod<
    [_subcourtID: BigNumberish, _jurorsForCourtJump: BigNumberish],
    [void],
    "nonpayable"
  >;

  appealPeriod: TypedContractMethod<
    [_disputeID: BigNumberish],
    [[bigint, bigint] & { start: bigint; end: bigint }],
    "view"
  >;

  phase: TypedContractMethod<[], [bigint], "view">;

  MAX_STAKE_PATHS: TypedContractMethod<[], [bigint], "view">;

  delayedSetStakes: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [string, bigint, bigint] & {
        account: string;
        subcourtID: bigint;
        stake: bigint;
      }
    ],
    "view"
  >;

  lastPhaseChange: TypedContractMethod<[], [bigint], "view">;

  minStakingTime: TypedContractMethod<[], [bigint], "view">;

  nextDelayedSetStake: TypedContractMethod<[], [bigint], "view">;

  createDispute: TypedContractMethod<
    [_numberOfChoices: BigNumberish, _extraData: BytesLike],
    [bigint],
    "payable"
  >;

  drawJurors: TypedContractMethod<
    [_disputeID: BigNumberish, _iterations: BigNumberish],
    [void],
    "nonpayable"
  >;

  createSubcourt: TypedContractMethod<
    [
      _parent: BigNumberish,
      _hiddenVotes: boolean,
      _minStake: BigNumberish,
      _alpha: BigNumberish,
      _feeForJuror: BigNumberish,
      _jurorsForCourtJump: BigNumberish,
      _timesPerPeriod: [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
      _sortitionSumTreeK: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  getJuror: TypedContractMethod<[_account: AddressLike], [bigint[]], "view">;

  onApprove: TypedContractMethod<
    [_owner: AddressLike, _spender: AddressLike, _amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  jurors: TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, bigint] & { stakedTokens: bigint; lockedTokens: bigint }],
    "view"
  >;

  changeMaxDrawingTime: TypedContractMethod<
    [_maxDrawingTime: BigNumberish],
    [void],
    "nonpayable"
  >;

  getDispute: TypedContractMethod<
    [_disputeID: BigNumberish],
    [
      [bigint[], bigint[], bigint[], bigint[], bigint[], bigint[]] & {
        votesLengths: bigint[];
        tokensAtStakePerJuror: bigint[];
        totalFeesForJurors: bigint[];
        votesInEachRound: bigint[];
        repartitionsInEachRound: bigint[];
        penaltiesInEachRound: bigint[];
      }
    ],
    "view"
  >;

  getVoteCounter: TypedContractMethod<
    [_disputeID: BigNumberish, _appeal: BigNumberish],
    [
      [bigint, bigint[], boolean] & {
        winningChoice: bigint;
        counts: bigint[];
        tied: boolean;
      }
    ],
    "view"
  >;

  changeGovernor: TypedContractMethod<
    [_governor: AddressLike],
    [void],
    "nonpayable"
  >;

  MIN_JURORS: TypedContractMethod<[], [bigint], "view">;

  appealCost: TypedContractMethod<
    [_disputeID: BigNumberish, _extraData: BytesLike],
    [bigint],
    "view"
  >;

  proxyPayment: TypedContractMethod<
    [_owner: AddressLike],
    [boolean],
    "payable"
  >;

  lockInsolventTransfers: TypedContractMethod<[], [boolean], "view">;

  arbitrationCost: TypedContractMethod<
    [_extraData: BytesLike],
    [bigint],
    "view"
  >;

  pinakion: TypedContractMethod<[], [string], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "changePinakion"
  ): TypedContractMethod<[_pinakion: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "RNBlock"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "disputesWithoutJurors"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "passPhase"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "governor"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "lastDelayedSetStake"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "disputeStatus"
  ): TypedContractMethod<[_disputeID: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "passPeriod"
  ): TypedContractMethod<[_disputeID: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "maxDrawingTime"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "currentRuling"
  ): TypedContractMethod<[_disputeID: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "courts"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, boolean, bigint, bigint, bigint, bigint] & {
        parent: bigint;
        hiddenVotes: boolean;
        minStake: bigint;
        alpha: bigint;
        feeForJuror: bigint;
        jurorsForCourtJump: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "execute"
  ): TypedContractMethod<
    [
      _disputeID: BigNumberish,
      _appeal: BigNumberish,
      _iterations: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "ALPHA_DIVISOR"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "castVote"
  ): TypedContractMethod<
    [
      _disputeID: BigNumberish,
      _voteIDs: BigNumberish[],
      _choice: BigNumberish,
      _salt: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "changeSubcourtMinStake"
  ): TypedContractMethod<
    [_subcourtID: BigNumberish, _minStake: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getSubcourt"
  ): TypedContractMethod<
    [_subcourtID: BigNumberish],
    [
      [bigint[], [bigint, bigint, bigint, bigint]] & {
        children: bigint[];
        timesPerPeriod: [bigint, bigint, bigint, bigint];
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "appeal"
  ): TypedContractMethod<
    [_disputeID: BigNumberish, _extraData: BytesLike],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "onTransfer"
  ): TypedContractMethod<
    [_from: AddressLike, _to: AddressLike, _amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "disputes"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, string, bigint, bigint, bigint, bigint, bigint, boolean] & {
        subcourtID: bigint;
        arbitrated: string;
        numberOfChoices: bigint;
        period: bigint;
        lastPeriodChange: bigint;
        drawsInRound: bigint;
        commitsInRound: bigint;
        ruled: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "changeSubcourtTimesPerPeriod"
  ): TypedContractMethod<
    [
      _subcourtID: BigNumberish,
      _timesPerPeriod: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "changeSubcourtJurorFee"
  ): TypedContractMethod<
    [_subcourtID: BigNumberish, _feeForJuror: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "changeSubcourtAlpha"
  ): TypedContractMethod<
    [_subcourtID: BigNumberish, _alpha: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "castCommit"
  ): TypedContractMethod<
    [_disputeID: BigNumberish, _voteIDs: BigNumberish[], _commit: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(nameOrSignature: "RN"): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "RNGenerator"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "executeGovernorProposal"
  ): TypedContractMethod<
    [_destination: AddressLike, _amount: BigNumberish, _data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "changeMinStakingTime"
  ): TypedContractMethod<[_minStakingTime: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "NON_PAYABLE_AMOUNT"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "setStake"
  ): TypedContractMethod<
    [_subcourtID: BigNumberish, _stake: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "executeRuling"
  ): TypedContractMethod<[_disputeID: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getVote"
  ): TypedContractMethod<
    [_disputeID: BigNumberish, _appeal: BigNumberish, _voteID: BigNumberish],
    [
      [string, string, bigint, boolean] & {
        account: string;
        commit: string;
        choice: bigint;
        voted: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "changeRNGenerator"
  ): TypedContractMethod<[_RNGenerator: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "executeDelayedSetStakes"
  ): TypedContractMethod<[_iterations: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "stakeOf"
  ): TypedContractMethod<
    [_account: AddressLike, _subcourtID: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "changeSubcourtJurorsForJump"
  ): TypedContractMethod<
    [_subcourtID: BigNumberish, _jurorsForCourtJump: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "appealPeriod"
  ): TypedContractMethod<
    [_disputeID: BigNumberish],
    [[bigint, bigint] & { start: bigint; end: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "phase"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "MAX_STAKE_PATHS"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "delayedSetStakes"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [string, bigint, bigint] & {
        account: string;
        subcourtID: bigint;
        stake: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "lastPhaseChange"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "minStakingTime"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "nextDelayedSetStake"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "createDispute"
  ): TypedContractMethod<
    [_numberOfChoices: BigNumberish, _extraData: BytesLike],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "drawJurors"
  ): TypedContractMethod<
    [_disputeID: BigNumberish, _iterations: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "createSubcourt"
  ): TypedContractMethod<
    [
      _parent: BigNumberish,
      _hiddenVotes: boolean,
      _minStake: BigNumberish,
      _alpha: BigNumberish,
      _feeForJuror: BigNumberish,
      _jurorsForCourtJump: BigNumberish,
      _timesPerPeriod: [BigNumberish, BigNumberish, BigNumberish, BigNumberish],
      _sortitionSumTreeK: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getJuror"
  ): TypedContractMethod<[_account: AddressLike], [bigint[]], "view">;
  getFunction(
    nameOrSignature: "onApprove"
  ): TypedContractMethod<
    [_owner: AddressLike, _spender: AddressLike, _amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "jurors"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, bigint] & { stakedTokens: bigint; lockedTokens: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "changeMaxDrawingTime"
  ): TypedContractMethod<[_maxDrawingTime: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getDispute"
  ): TypedContractMethod<
    [_disputeID: BigNumberish],
    [
      [bigint[], bigint[], bigint[], bigint[], bigint[], bigint[]] & {
        votesLengths: bigint[];
        tokensAtStakePerJuror: bigint[];
        totalFeesForJurors: bigint[];
        votesInEachRound: bigint[];
        repartitionsInEachRound: bigint[];
        penaltiesInEachRound: bigint[];
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getVoteCounter"
  ): TypedContractMethod<
    [_disputeID: BigNumberish, _appeal: BigNumberish],
    [
      [bigint, bigint[], boolean] & {
        winningChoice: bigint;
        counts: bigint[];
        tied: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "changeGovernor"
  ): TypedContractMethod<[_governor: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "MIN_JURORS"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "appealCost"
  ): TypedContractMethod<
    [_disputeID: BigNumberish, _extraData: BytesLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "proxyPayment"
  ): TypedContractMethod<[_owner: AddressLike], [boolean], "payable">;
  getFunction(
    nameOrSignature: "lockInsolventTransfers"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "arbitrationCost"
  ): TypedContractMethod<[_extraData: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "pinakion"
  ): TypedContractMethod<[], [string], "view">;

  getEvent(
    key: "NewPhase"
  ): TypedContractEvent<
    NewPhaseEvent.InputTuple,
    NewPhaseEvent.OutputTuple,
    NewPhaseEvent.OutputObject
  >;
  getEvent(
    key: "NewPeriod"
  ): TypedContractEvent<
    NewPeriodEvent.InputTuple,
    NewPeriodEvent.OutputTuple,
    NewPeriodEvent.OutputObject
  >;
  getEvent(
    key: "StakeSet"
  ): TypedContractEvent<
    StakeSetEvent.InputTuple,
    StakeSetEvent.OutputTuple,
    StakeSetEvent.OutputObject
  >;
  getEvent(
    key: "Draw"
  ): TypedContractEvent<
    DrawEvent.InputTuple,
    DrawEvent.OutputTuple,
    DrawEvent.OutputObject
  >;
  getEvent(
    key: "TokenAndETHShift"
  ): TypedContractEvent<
    TokenAndETHShiftEvent.InputTuple,
    TokenAndETHShiftEvent.OutputTuple,
    TokenAndETHShiftEvent.OutputObject
  >;
  getEvent(
    key: "DisputeCreation"
  ): TypedContractEvent<
    DisputeCreationEvent.InputTuple,
    DisputeCreationEvent.OutputTuple,
    DisputeCreationEvent.OutputObject
  >;
  getEvent(
    key: "AppealPossible"
  ): TypedContractEvent<
    AppealPossibleEvent.InputTuple,
    AppealPossibleEvent.OutputTuple,
    AppealPossibleEvent.OutputObject
  >;
  getEvent(
    key: "AppealDecision"
  ): TypedContractEvent<
    AppealDecisionEvent.InputTuple,
    AppealDecisionEvent.OutputTuple,
    AppealDecisionEvent.OutputObject
  >;

  filters: {
    "NewPhase(uint8)": TypedContractEvent<
      NewPhaseEvent.InputTuple,
      NewPhaseEvent.OutputTuple,
      NewPhaseEvent.OutputObject
    >;
    NewPhase: TypedContractEvent<
      NewPhaseEvent.InputTuple,
      NewPhaseEvent.OutputTuple,
      NewPhaseEvent.OutputObject
    >;

    "NewPeriod(uint256,uint8)": TypedContractEvent<
      NewPeriodEvent.InputTuple,
      NewPeriodEvent.OutputTuple,
      NewPeriodEvent.OutputObject
    >;
    NewPeriod: TypedContractEvent<
      NewPeriodEvent.InputTuple,
      NewPeriodEvent.OutputTuple,
      NewPeriodEvent.OutputObject
    >;

    "StakeSet(address,uint256,uint128,uint256)": TypedContractEvent<
      StakeSetEvent.InputTuple,
      StakeSetEvent.OutputTuple,
      StakeSetEvent.OutputObject
    >;
    StakeSet: TypedContractEvent<
      StakeSetEvent.InputTuple,
      StakeSetEvent.OutputTuple,
      StakeSetEvent.OutputObject
    >;

    "Draw(address,uint256,uint256,uint256)": TypedContractEvent<
      DrawEvent.InputTuple,
      DrawEvent.OutputTuple,
      DrawEvent.OutputObject
    >;
    Draw: TypedContractEvent<
      DrawEvent.InputTuple,
      DrawEvent.OutputTuple,
      DrawEvent.OutputObject
    >;

    "TokenAndETHShift(address,uint256,int256,int256)": TypedContractEvent<
      TokenAndETHShiftEvent.InputTuple,
      TokenAndETHShiftEvent.OutputTuple,
      TokenAndETHShiftEvent.OutputObject
    >;
    TokenAndETHShift: TypedContractEvent<
      TokenAndETHShiftEvent.InputTuple,
      TokenAndETHShiftEvent.OutputTuple,
      TokenAndETHShiftEvent.OutputObject
    >;

    "DisputeCreation(uint256,address)": TypedContractEvent<
      DisputeCreationEvent.InputTuple,
      DisputeCreationEvent.OutputTuple,
      DisputeCreationEvent.OutputObject
    >;
    DisputeCreation: TypedContractEvent<
      DisputeCreationEvent.InputTuple,
      DisputeCreationEvent.OutputTuple,
      DisputeCreationEvent.OutputObject
    >;

    "AppealPossible(uint256,address)": TypedContractEvent<
      AppealPossibleEvent.InputTuple,
      AppealPossibleEvent.OutputTuple,
      AppealPossibleEvent.OutputObject
    >;
    AppealPossible: TypedContractEvent<
      AppealPossibleEvent.InputTuple,
      AppealPossibleEvent.OutputTuple,
      AppealPossibleEvent.OutputObject
    >;

    "AppealDecision(uint256,address)": TypedContractEvent<
      AppealDecisionEvent.InputTuple,
      AppealDecisionEvent.OutputTuple,
      AppealDecisionEvent.OutputObject
    >;
    AppealDecision: TypedContractEvent<
      AppealDecisionEvent.InputTuple,
      AppealDecisionEvent.OutputTuple,
      AppealDecisionEvent.OutputObject
    >;
  };
}
