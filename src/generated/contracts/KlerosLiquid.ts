/* Autogenerated file. Do not edit manually. */

/* tslint:disable */

/* eslint-disable */
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";

export interface KlerosLiquidInterface extends utils.Interface {
  functions: {
    "changePinakion(address)": FunctionFragment;
    "RNBlock()": FunctionFragment;
    "disputesWithoutJurors()": FunctionFragment;
    "passPhase()": FunctionFragment;
    "governor()": FunctionFragment;
    "lastDelayedSetStake()": FunctionFragment;
    "disputeStatus(uint256)": FunctionFragment;
    "passPeriod(uint256)": FunctionFragment;
    "maxDrawingTime()": FunctionFragment;
    "currentRuling(uint256)": FunctionFragment;
    "courts(uint256)": FunctionFragment;
    "execute(uint256,uint256,uint256)": FunctionFragment;
    "ALPHA_DIVISOR()": FunctionFragment;
    "castVote(uint256,uint256[],uint256,uint256)": FunctionFragment;
    "changeSubcourtMinStake(uint96,uint256)": FunctionFragment;
    "getSubcourt(uint96)": FunctionFragment;
    "appeal(uint256,bytes)": FunctionFragment;
    "onTransfer(address,address,uint256)": FunctionFragment;
    "disputes(uint256)": FunctionFragment;
    "changeSubcourtTimesPerPeriod(uint96,uint256[4])": FunctionFragment;
    "changeSubcourtJurorFee(uint96,uint256)": FunctionFragment;
    "changeSubcourtAlpha(uint96,uint256)": FunctionFragment;
    "castCommit(uint256,uint256[],bytes32)": FunctionFragment;
    "RN()": FunctionFragment;
    "RNGenerator()": FunctionFragment;
    "executeGovernorProposal(address,uint256,bytes)": FunctionFragment;
    "changeMinStakingTime(uint256)": FunctionFragment;
    "NON_PAYABLE_AMOUNT()": FunctionFragment;
    "setStake(uint96,uint128)": FunctionFragment;
    "executeRuling(uint256)": FunctionFragment;
    "getVote(uint256,uint256,uint256)": FunctionFragment;
    "changeRNGenerator(address)": FunctionFragment;
    "executeDelayedSetStakes(uint256)": FunctionFragment;
    "stakeOf(address,uint96)": FunctionFragment;
    "changeSubcourtJurorsForJump(uint96,uint256)": FunctionFragment;
    "appealPeriod(uint256)": FunctionFragment;
    "phase()": FunctionFragment;
    "MAX_STAKE_PATHS()": FunctionFragment;
    "delayedSetStakes(uint256)": FunctionFragment;
    "lastPhaseChange()": FunctionFragment;
    "minStakingTime()": FunctionFragment;
    "nextDelayedSetStake()": FunctionFragment;
    "createDispute(uint256,bytes)": FunctionFragment;
    "drawJurors(uint256,uint256)": FunctionFragment;
    "createSubcourt(uint96,bool,uint256,uint256,uint256,uint256,uint256[4],uint256)": FunctionFragment;
    "getJuror(address)": FunctionFragment;
    "onApprove(address,address,uint256)": FunctionFragment;
    "jurors(address)": FunctionFragment;
    "changeMaxDrawingTime(uint256)": FunctionFragment;
    "getDispute(uint256)": FunctionFragment;
    "getVoteCounter(uint256,uint256)": FunctionFragment;
    "changeGovernor(address)": FunctionFragment;
    "MIN_JURORS()": FunctionFragment;
    "appealCost(uint256,bytes)": FunctionFragment;
    "proxyPayment(address)": FunctionFragment;
    "lockInsolventTransfers()": FunctionFragment;
    "arbitrationCost(bytes)": FunctionFragment;
    "pinakion()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "changePinakion"
      | "RNBlock"
      | "disputesWithoutJurors"
      | "passPhase"
      | "governor"
      | "lastDelayedSetStake"
      | "disputeStatus"
      | "passPeriod"
      | "maxDrawingTime"
      | "currentRuling"
      | "courts"
      | "execute"
      | "ALPHA_DIVISOR"
      | "castVote"
      | "changeSubcourtMinStake"
      | "getSubcourt"
      | "appeal"
      | "onTransfer"
      | "disputes"
      | "changeSubcourtTimesPerPeriod"
      | "changeSubcourtJurorFee"
      | "changeSubcourtAlpha"
      | "castCommit"
      | "RN"
      | "RNGenerator"
      | "executeGovernorProposal"
      | "changeMinStakingTime"
      | "NON_PAYABLE_AMOUNT"
      | "setStake"
      | "executeRuling"
      | "getVote"
      | "changeRNGenerator"
      | "executeDelayedSetStakes"
      | "stakeOf"
      | "changeSubcourtJurorsForJump"
      | "appealPeriod"
      | "phase"
      | "MAX_STAKE_PATHS"
      | "delayedSetStakes"
      | "lastPhaseChange"
      | "minStakingTime"
      | "nextDelayedSetStake"
      | "createDispute"
      | "drawJurors"
      | "createSubcourt"
      | "getJuror"
      | "onApprove"
      | "jurors"
      | "changeMaxDrawingTime"
      | "getDispute"
      | "getVoteCounter"
      | "changeGovernor"
      | "MIN_JURORS"
      | "appealCost"
      | "proxyPayment"
      | "lockInsolventTransfers"
      | "arbitrationCost"
      | "pinakion"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "changePinakion",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "RNBlock", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "disputesWithoutJurors",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "passPhase", values?: undefined): string;
  encodeFunctionData(functionFragment: "governor", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "lastDelayedSetStake",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "disputeStatus",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "passPeriod",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "maxDrawingTime",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "currentRuling",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "courts",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "execute",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "ALPHA_DIVISOR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "castVote",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "changeSubcourtMinStake",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getSubcourt",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "appeal",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "onTransfer",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "disputes",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeSubcourtTimesPerPeriod",
    values: [
      PromiseOrValue<BigNumberish>,
      [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "changeSubcourtJurorFee",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeSubcourtAlpha",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "castCommit",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(functionFragment: "RN", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "RNGenerator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "executeGovernorProposal",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "changeMinStakingTime",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "NON_PAYABLE_AMOUNT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setStake",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "executeRuling",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getVote",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "changeRNGenerator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "executeDelayedSetStakes",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakeOf",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeSubcourtJurorsForJump",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "appealPeriod",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "phase", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "MAX_STAKE_PATHS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "delayedSetStakes",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "lastPhaseChange",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minStakingTime",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nextDelayedSetStake",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "createDispute",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "drawJurors",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "createSubcourt",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getJuror",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "onApprove",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "jurors",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeMaxDrawingTime",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getDispute",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getVoteCounter",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeGovernor",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_JURORS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "appealCost",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "proxyPayment",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "lockInsolventTransfers",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "arbitrationCost",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "pinakion", values?: undefined): string;

  decodeFunctionResult(
    functionFragment: "changePinakion",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "RNBlock", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "disputesWithoutJurors",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "passPhase", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "governor", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "lastDelayedSetStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disputeStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "passPeriod", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "maxDrawingTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentRuling",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "courts", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "execute", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "ALPHA_DIVISOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "castVote", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeSubcourtMinStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSubcourt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "appeal", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "onTransfer", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "disputes", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeSubcourtTimesPerPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeSubcourtJurorFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeSubcourtAlpha",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "castCommit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "RN", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "RNGenerator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeGovernorProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeMinStakingTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "NON_PAYABLE_AMOUNT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setStake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executeRuling",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getVote", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeRNGenerator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeDelayedSetStakes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "stakeOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeSubcourtJurorsForJump",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "appealPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "phase", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "MAX_STAKE_PATHS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "delayedSetStakes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastPhaseChange",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minStakingTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nextDelayedSetStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createDispute",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "drawJurors", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createSubcourt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getJuror", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "onApprove", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "jurors", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeMaxDrawingTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getDispute", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getVoteCounter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeGovernor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "MIN_JURORS", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "appealCost", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proxyPayment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lockInsolventTransfers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "arbitrationCost",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pinakion", data: BytesLike): Result;

  events: {
    "NewPhase(uint8)": EventFragment;
    "NewPeriod(uint256,uint8)": EventFragment;
    "StakeSet(address,uint256,uint128,uint256)": EventFragment;
    "Draw(address,uint256,uint256,uint256)": EventFragment;
    "TokenAndETHShift(address,uint256,int256,int256)": EventFragment;
    "DisputeCreation(uint256,address)": EventFragment;
    "AppealPossible(uint256,address)": EventFragment;
    "AppealDecision(uint256,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "NewPhase"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewPeriod"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Draw"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenAndETHShift"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DisputeCreation"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AppealPossible"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AppealDecision"): EventFragment;
}

export interface NewPhaseEventObject {
  _phase: number;
}
export type NewPhaseEvent = TypedEvent<[number], NewPhaseEventObject>;

export type NewPhaseEventFilter = TypedEventFilter<NewPhaseEvent>;

export interface NewPeriodEventObject {
  _disputeID: BigNumber;
  _period: number;
}
export type NewPeriodEvent = TypedEvent<
  [BigNumber, number],
  NewPeriodEventObject
>;

export type NewPeriodEventFilter = TypedEventFilter<NewPeriodEvent>;

export interface StakeSetEventObject {
  _address: string;
  _subcourtID: BigNumber;
  _stake: BigNumber;
  _newTotalStake: BigNumber;
}
export type StakeSetEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  StakeSetEventObject
>;

export type StakeSetEventFilter = TypedEventFilter<StakeSetEvent>;

export interface DrawEventObject {
  _address: string;
  _disputeID: BigNumber;
  _appeal: BigNumber;
  _voteID: BigNumber;
}
export type DrawEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  DrawEventObject
>;

export type DrawEventFilter = TypedEventFilter<DrawEvent>;

export interface TokenAndETHShiftEventObject {
  _address: string;
  _disputeID: BigNumber;
  _tokenAmount: BigNumber;
  _ETHAmount: BigNumber;
}
export type TokenAndETHShiftEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  TokenAndETHShiftEventObject
>;

export type TokenAndETHShiftEventFilter =
  TypedEventFilter<TokenAndETHShiftEvent>;

export interface DisputeCreationEventObject {
  _disputeID: BigNumber;
  _arbitrable: string;
}
export type DisputeCreationEvent = TypedEvent<
  [BigNumber, string],
  DisputeCreationEventObject
>;

export type DisputeCreationEventFilter = TypedEventFilter<DisputeCreationEvent>;

export interface AppealPossibleEventObject {
  _disputeID: BigNumber;
  _arbitrable: string;
}
export type AppealPossibleEvent = TypedEvent<
  [BigNumber, string],
  AppealPossibleEventObject
>;

export type AppealPossibleEventFilter = TypedEventFilter<AppealPossibleEvent>;

export interface AppealDecisionEventObject {
  _disputeID: BigNumber;
  _arbitrable: string;
}
export type AppealDecisionEvent = TypedEvent<
  [BigNumber, string],
  AppealDecisionEventObject
>;

export type AppealDecisionEventFilter = TypedEventFilter<AppealDecisionEvent>;

export interface KlerosLiquid extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: KlerosLiquidInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    changePinakion(
      _pinakion: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    RNBlock(overrides?: CallOverrides): Promise<[BigNumber]>;

    disputesWithoutJurors(overrides?: CallOverrides): Promise<[BigNumber]>;

    passPhase(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    governor(overrides?: CallOverrides): Promise<[string]>;

    lastDelayedSetStake(overrides?: CallOverrides): Promise<[BigNumber]>;

    disputeStatus(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number] & { status: number }>;

    passPeriod(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    maxDrawingTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    currentRuling(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { ruling: BigNumber }>;

    courts(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean, BigNumber, BigNumber, BigNumber, BigNumber] & {
        parent: BigNumber;
        hiddenVotes: boolean;
        minStake: BigNumber;
        alpha: BigNumber;
        feeForJuror: BigNumber;
        jurorsForCourtJump: BigNumber;
      }
    >;

    execute(
      _disputeID: PromiseOrValue<BigNumberish>,
      _appeal: PromiseOrValue<BigNumberish>,
      _iterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    ALPHA_DIVISOR(overrides?: CallOverrides): Promise<[BigNumber]>;

    castVote(
      _disputeID: PromiseOrValue<BigNumberish>,
      _voteIDs: PromiseOrValue<BigNumberish>[],
      _choice: PromiseOrValue<BigNumberish>,
      _salt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    changeSubcourtMinStake(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _minStake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getSubcourt(
      _subcourtID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], [BigNumber, BigNumber, BigNumber, BigNumber]] & {
        children: BigNumber[];
        timesPerPeriod: [BigNumber, BigNumber, BigNumber, BigNumber];
      }
    >;

    appeal(
      _disputeID: PromiseOrValue<BigNumberish>,
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    onTransfer(
      _from: PromiseOrValue<string>,
      _to: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    disputes(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        string,
        BigNumber,
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean
      ] & {
        subcourtID: BigNumber;
        arbitrated: string;
        numberOfChoices: BigNumber;
        period: number;
        lastPeriodChange: BigNumber;
        drawsInRound: BigNumber;
        commitsInRound: BigNumber;
        ruled: boolean;
      }
    >;

    changeSubcourtTimesPerPeriod(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _timesPerPeriod: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    changeSubcourtJurorFee(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _feeForJuror: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    changeSubcourtAlpha(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _alpha: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    castCommit(
      _disputeID: PromiseOrValue<BigNumberish>,
      _voteIDs: PromiseOrValue<BigNumberish>[],
      _commit: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    RN(overrides?: CallOverrides): Promise<[BigNumber]>;

    RNGenerator(overrides?: CallOverrides): Promise<[string]>;

    executeGovernorProposal(
      _destination: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    changeMinStakingTime(
      _minStakingTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    NON_PAYABLE_AMOUNT(overrides?: CallOverrides): Promise<[BigNumber]>;

    setStake(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _stake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    executeRuling(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getVote(
      _disputeID: PromiseOrValue<BigNumberish>,
      _appeal: PromiseOrValue<BigNumberish>,
      _voteID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, string, BigNumber, boolean] & {
        account: string;
        commit: string;
        choice: BigNumber;
        voted: boolean;
      }
    >;

    changeRNGenerator(
      _RNGenerator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    executeDelayedSetStakes(
      _iterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakeOf(
      _account: PromiseOrValue<string>,
      _subcourtID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { stake: BigNumber }>;

    changeSubcourtJurorsForJump(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _jurorsForCourtJump: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    appealPeriod(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { start: BigNumber; end: BigNumber }>;

    phase(overrides?: CallOverrides): Promise<[number]>;

    MAX_STAKE_PATHS(overrides?: CallOverrides): Promise<[BigNumber]>;

    delayedSetStakes(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, BigNumber] & {
        account: string;
        subcourtID: BigNumber;
        stake: BigNumber;
      }
    >;

    lastPhaseChange(overrides?: CallOverrides): Promise<[BigNumber]>;

    minStakingTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    nextDelayedSetStake(overrides?: CallOverrides): Promise<[BigNumber]>;

    createDispute(
      _numberOfChoices: PromiseOrValue<BigNumberish>,
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    drawJurors(
      _disputeID: PromiseOrValue<BigNumberish>,
      _iterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createSubcourt(
      _parent: PromiseOrValue<BigNumberish>,
      _hiddenVotes: PromiseOrValue<boolean>,
      _minStake: PromiseOrValue<BigNumberish>,
      _alpha: PromiseOrValue<BigNumberish>,
      _feeForJuror: PromiseOrValue<BigNumberish>,
      _jurorsForCourtJump: PromiseOrValue<BigNumberish>,
      _timesPerPeriod: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      _sortitionSumTreeK: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getJuror(
      _account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { subcourtIDs: BigNumber[] }>;

    onApprove(
      _owner: PromiseOrValue<string>,
      _spender: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    jurors(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        stakedTokens: BigNumber;
        lockedTokens: BigNumber;
      }
    >;

    changeMaxDrawingTime(
      _maxDrawingTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getDispute(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber[],
        BigNumber[],
        BigNumber[],
        BigNumber[],
        BigNumber[],
        BigNumber[]
      ] & {
        votesLengths: BigNumber[];
        tokensAtStakePerJuror: BigNumber[];
        totalFeesForJurors: BigNumber[];
        votesInEachRound: BigNumber[];
        repartitionsInEachRound: BigNumber[];
        penaltiesInEachRound: BigNumber[];
      }
    >;

    getVoteCounter(
      _disputeID: PromiseOrValue<BigNumberish>,
      _appeal: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber[], boolean] & {
        winningChoice: BigNumber;
        counts: BigNumber[];
        tied: boolean;
      }
    >;

    changeGovernor(
      _governor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    MIN_JURORS(overrides?: CallOverrides): Promise<[BigNumber]>;

    appealCost(
      _disputeID: PromiseOrValue<BigNumberish>,
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { cost: BigNumber }>;

    proxyPayment(
      _owner: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    lockInsolventTransfers(overrides?: CallOverrides): Promise<[boolean]>;

    arbitrationCost(
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { cost: BigNumber }>;

    pinakion(overrides?: CallOverrides): Promise<[string]>;
  };

  changePinakion(
    _pinakion: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  RNBlock(overrides?: CallOverrides): Promise<BigNumber>;

  disputesWithoutJurors(overrides?: CallOverrides): Promise<BigNumber>;

  passPhase(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  governor(overrides?: CallOverrides): Promise<string>;

  lastDelayedSetStake(overrides?: CallOverrides): Promise<BigNumber>;

  disputeStatus(
    _disputeID: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<number>;

  passPeriod(
    _disputeID: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  maxDrawingTime(overrides?: CallOverrides): Promise<BigNumber>;

  currentRuling(
    _disputeID: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  courts(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, boolean, BigNumber, BigNumber, BigNumber, BigNumber] & {
      parent: BigNumber;
      hiddenVotes: boolean;
      minStake: BigNumber;
      alpha: BigNumber;
      feeForJuror: BigNumber;
      jurorsForCourtJump: BigNumber;
    }
  >;

  execute(
    _disputeID: PromiseOrValue<BigNumberish>,
    _appeal: PromiseOrValue<BigNumberish>,
    _iterations: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  ALPHA_DIVISOR(overrides?: CallOverrides): Promise<BigNumber>;

  castVote(
    _disputeID: PromiseOrValue<BigNumberish>,
    _voteIDs: PromiseOrValue<BigNumberish>[],
    _choice: PromiseOrValue<BigNumberish>,
    _salt: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  changeSubcourtMinStake(
    _subcourtID: PromiseOrValue<BigNumberish>,
    _minStake: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getSubcourt(
    _subcourtID: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], [BigNumber, BigNumber, BigNumber, BigNumber]] & {
      children: BigNumber[];
      timesPerPeriod: [BigNumber, BigNumber, BigNumber, BigNumber];
    }
  >;

  appeal(
    _disputeID: PromiseOrValue<BigNumberish>,
    _extraData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  onTransfer(
    _from: PromiseOrValue<string>,
    _to: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  disputes(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      string,
      BigNumber,
      number,
      BigNumber,
      BigNumber,
      BigNumber,
      boolean
    ] & {
      subcourtID: BigNumber;
      arbitrated: string;
      numberOfChoices: BigNumber;
      period: number;
      lastPeriodChange: BigNumber;
      drawsInRound: BigNumber;
      commitsInRound: BigNumber;
      ruled: boolean;
    }
  >;

  changeSubcourtTimesPerPeriod(
    _subcourtID: PromiseOrValue<BigNumberish>,
    _timesPerPeriod: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  changeSubcourtJurorFee(
    _subcourtID: PromiseOrValue<BigNumberish>,
    _feeForJuror: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  changeSubcourtAlpha(
    _subcourtID: PromiseOrValue<BigNumberish>,
    _alpha: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  castCommit(
    _disputeID: PromiseOrValue<BigNumberish>,
    _voteIDs: PromiseOrValue<BigNumberish>[],
    _commit: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  RN(overrides?: CallOverrides): Promise<BigNumber>;

  RNGenerator(overrides?: CallOverrides): Promise<string>;

  executeGovernorProposal(
    _destination: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    _data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  changeMinStakingTime(
    _minStakingTime: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  NON_PAYABLE_AMOUNT(overrides?: CallOverrides): Promise<BigNumber>;

  setStake(
    _subcourtID: PromiseOrValue<BigNumberish>,
    _stake: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  executeRuling(
    _disputeID: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getVote(
    _disputeID: PromiseOrValue<BigNumberish>,
    _appeal: PromiseOrValue<BigNumberish>,
    _voteID: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [string, string, BigNumber, boolean] & {
      account: string;
      commit: string;
      choice: BigNumber;
      voted: boolean;
    }
  >;

  changeRNGenerator(
    _RNGenerator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  executeDelayedSetStakes(
    _iterations: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakeOf(
    _account: PromiseOrValue<string>,
    _subcourtID: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  changeSubcourtJurorsForJump(
    _subcourtID: PromiseOrValue<BigNumberish>,
    _jurorsForCourtJump: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  appealPeriod(
    _disputeID: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber] & { start: BigNumber; end: BigNumber }>;

  phase(overrides?: CallOverrides): Promise<number>;

  MAX_STAKE_PATHS(overrides?: CallOverrides): Promise<BigNumber>;

  delayedSetStakes(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber, BigNumber] & {
      account: string;
      subcourtID: BigNumber;
      stake: BigNumber;
    }
  >;

  lastPhaseChange(overrides?: CallOverrides): Promise<BigNumber>;

  minStakingTime(overrides?: CallOverrides): Promise<BigNumber>;

  nextDelayedSetStake(overrides?: CallOverrides): Promise<BigNumber>;

  createDispute(
    _numberOfChoices: PromiseOrValue<BigNumberish>,
    _extraData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  drawJurors(
    _disputeID: PromiseOrValue<BigNumberish>,
    _iterations: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createSubcourt(
    _parent: PromiseOrValue<BigNumberish>,
    _hiddenVotes: PromiseOrValue<boolean>,
    _minStake: PromiseOrValue<BigNumberish>,
    _alpha: PromiseOrValue<BigNumberish>,
    _feeForJuror: PromiseOrValue<BigNumberish>,
    _jurorsForCourtJump: PromiseOrValue<BigNumberish>,
    _timesPerPeriod: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ],
    _sortitionSumTreeK: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getJuror(
    _account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  onApprove(
    _owner: PromiseOrValue<string>,
    _spender: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  jurors(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & {
      stakedTokens: BigNumber;
      lockedTokens: BigNumber;
    }
  >;

  changeMaxDrawingTime(
    _maxDrawingTime: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getDispute(
    _disputeID: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber[],
      BigNumber[],
      BigNumber[],
      BigNumber[],
      BigNumber[],
      BigNumber[]
    ] & {
      votesLengths: BigNumber[];
      tokensAtStakePerJuror: BigNumber[];
      totalFeesForJurors: BigNumber[];
      votesInEachRound: BigNumber[];
      repartitionsInEachRound: BigNumber[];
      penaltiesInEachRound: BigNumber[];
    }
  >;

  getVoteCounter(
    _disputeID: PromiseOrValue<BigNumberish>,
    _appeal: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber[], boolean] & {
      winningChoice: BigNumber;
      counts: BigNumber[];
      tied: boolean;
    }
  >;

  changeGovernor(
    _governor: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  MIN_JURORS(overrides?: CallOverrides): Promise<BigNumber>;

  appealCost(
    _disputeID: PromiseOrValue<BigNumberish>,
    _extraData: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  proxyPayment(
    _owner: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  lockInsolventTransfers(overrides?: CallOverrides): Promise<boolean>;

  arbitrationCost(
    _extraData: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  pinakion(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    changePinakion(
      _pinakion: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    RNBlock(overrides?: CallOverrides): Promise<BigNumber>;

    disputesWithoutJurors(overrides?: CallOverrides): Promise<BigNumber>;

    passPhase(overrides?: CallOverrides): Promise<void>;

    governor(overrides?: CallOverrides): Promise<string>;

    lastDelayedSetStake(overrides?: CallOverrides): Promise<BigNumber>;

    disputeStatus(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<number>;

    passPeriod(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    maxDrawingTime(overrides?: CallOverrides): Promise<BigNumber>;

    currentRuling(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    courts(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean, BigNumber, BigNumber, BigNumber, BigNumber] & {
        parent: BigNumber;
        hiddenVotes: boolean;
        minStake: BigNumber;
        alpha: BigNumber;
        feeForJuror: BigNumber;
        jurorsForCourtJump: BigNumber;
      }
    >;

    execute(
      _disputeID: PromiseOrValue<BigNumberish>,
      _appeal: PromiseOrValue<BigNumberish>,
      _iterations: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    ALPHA_DIVISOR(overrides?: CallOverrides): Promise<BigNumber>;

    castVote(
      _disputeID: PromiseOrValue<BigNumberish>,
      _voteIDs: PromiseOrValue<BigNumberish>[],
      _choice: PromiseOrValue<BigNumberish>,
      _salt: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    changeSubcourtMinStake(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _minStake: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getSubcourt(
      _subcourtID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], [BigNumber, BigNumber, BigNumber, BigNumber]] & {
        children: BigNumber[];
        timesPerPeriod: [BigNumber, BigNumber, BigNumber, BigNumber];
      }
    >;

    appeal(
      _disputeID: PromiseOrValue<BigNumberish>,
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    onTransfer(
      _from: PromiseOrValue<string>,
      _to: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    disputes(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        string,
        BigNumber,
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean
      ] & {
        subcourtID: BigNumber;
        arbitrated: string;
        numberOfChoices: BigNumber;
        period: number;
        lastPeriodChange: BigNumber;
        drawsInRound: BigNumber;
        commitsInRound: BigNumber;
        ruled: boolean;
      }
    >;

    changeSubcourtTimesPerPeriod(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _timesPerPeriod: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      overrides?: CallOverrides
    ): Promise<void>;

    changeSubcourtJurorFee(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _feeForJuror: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    changeSubcourtAlpha(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _alpha: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    castCommit(
      _disputeID: PromiseOrValue<BigNumberish>,
      _voteIDs: PromiseOrValue<BigNumberish>[],
      _commit: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    RN(overrides?: CallOverrides): Promise<BigNumber>;

    RNGenerator(overrides?: CallOverrides): Promise<string>;

    executeGovernorProposal(
      _destination: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    changeMinStakingTime(
      _minStakingTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    NON_PAYABLE_AMOUNT(overrides?: CallOverrides): Promise<BigNumber>;

    setStake(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _stake: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    executeRuling(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getVote(
      _disputeID: PromiseOrValue<BigNumberish>,
      _appeal: PromiseOrValue<BigNumberish>,
      _voteID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, string, BigNumber, boolean] & {
        account: string;
        commit: string;
        choice: BigNumber;
        voted: boolean;
      }
    >;

    changeRNGenerator(
      _RNGenerator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    executeDelayedSetStakes(
      _iterations: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    stakeOf(
      _account: PromiseOrValue<string>,
      _subcourtID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    changeSubcourtJurorsForJump(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _jurorsForCourtJump: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    appealPeriod(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { start: BigNumber; end: BigNumber }>;

    phase(overrides?: CallOverrides): Promise<number>;

    MAX_STAKE_PATHS(overrides?: CallOverrides): Promise<BigNumber>;

    delayedSetStakes(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, BigNumber] & {
        account: string;
        subcourtID: BigNumber;
        stake: BigNumber;
      }
    >;

    lastPhaseChange(overrides?: CallOverrides): Promise<BigNumber>;

    minStakingTime(overrides?: CallOverrides): Promise<BigNumber>;

    nextDelayedSetStake(overrides?: CallOverrides): Promise<BigNumber>;

    createDispute(
      _numberOfChoices: PromiseOrValue<BigNumberish>,
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    drawJurors(
      _disputeID: PromiseOrValue<BigNumberish>,
      _iterations: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    createSubcourt(
      _parent: PromiseOrValue<BigNumberish>,
      _hiddenVotes: PromiseOrValue<boolean>,
      _minStake: PromiseOrValue<BigNumberish>,
      _alpha: PromiseOrValue<BigNumberish>,
      _feeForJuror: PromiseOrValue<BigNumberish>,
      _jurorsForCourtJump: PromiseOrValue<BigNumberish>,
      _timesPerPeriod: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      _sortitionSumTreeK: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getJuror(
      _account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    onApprove(
      _owner: PromiseOrValue<string>,
      _spender: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    jurors(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        stakedTokens: BigNumber;
        lockedTokens: BigNumber;
      }
    >;

    changeMaxDrawingTime(
      _maxDrawingTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getDispute(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber[],
        BigNumber[],
        BigNumber[],
        BigNumber[],
        BigNumber[],
        BigNumber[]
      ] & {
        votesLengths: BigNumber[];
        tokensAtStakePerJuror: BigNumber[];
        totalFeesForJurors: BigNumber[];
        votesInEachRound: BigNumber[];
        repartitionsInEachRound: BigNumber[];
        penaltiesInEachRound: BigNumber[];
      }
    >;

    getVoteCounter(
      _disputeID: PromiseOrValue<BigNumberish>,
      _appeal: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber[], boolean] & {
        winningChoice: BigNumber;
        counts: BigNumber[];
        tied: boolean;
      }
    >;

    changeGovernor(
      _governor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    MIN_JURORS(overrides?: CallOverrides): Promise<BigNumber>;

    appealCost(
      _disputeID: PromiseOrValue<BigNumberish>,
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proxyPayment(
      _owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    lockInsolventTransfers(overrides?: CallOverrides): Promise<boolean>;

    arbitrationCost(
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    pinakion(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "NewPhase(uint8)"(_phase?: null): NewPhaseEventFilter;
    NewPhase(_phase?: null): NewPhaseEventFilter;

    "NewPeriod(uint256,uint8)"(
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _period?: null
    ): NewPeriodEventFilter;
    NewPeriod(
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _period?: null
    ): NewPeriodEventFilter;

    "StakeSet(address,uint256,uint128,uint256)"(
      _address?: PromiseOrValue<string> | null,
      _subcourtID?: null,
      _stake?: null,
      _newTotalStake?: null
    ): StakeSetEventFilter;
    StakeSet(
      _address?: PromiseOrValue<string> | null,
      _subcourtID?: null,
      _stake?: null,
      _newTotalStake?: null
    ): StakeSetEventFilter;

    "Draw(address,uint256,uint256,uint256)"(
      _address?: PromiseOrValue<string> | null,
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _appeal?: null,
      _voteID?: null
    ): DrawEventFilter;
    Draw(
      _address?: PromiseOrValue<string> | null,
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _appeal?: null,
      _voteID?: null
    ): DrawEventFilter;

    "TokenAndETHShift(address,uint256,int256,int256)"(
      _address?: PromiseOrValue<string> | null,
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _tokenAmount?: null,
      _ETHAmount?: null
    ): TokenAndETHShiftEventFilter;
    TokenAndETHShift(
      _address?: PromiseOrValue<string> | null,
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _tokenAmount?: null,
      _ETHAmount?: null
    ): TokenAndETHShiftEventFilter;

    "DisputeCreation(uint256,address)"(
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _arbitrable?: PromiseOrValue<string> | null
    ): DisputeCreationEventFilter;
    DisputeCreation(
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _arbitrable?: PromiseOrValue<string> | null
    ): DisputeCreationEventFilter;

    "AppealPossible(uint256,address)"(
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _arbitrable?: PromiseOrValue<string> | null
    ): AppealPossibleEventFilter;
    AppealPossible(
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _arbitrable?: PromiseOrValue<string> | null
    ): AppealPossibleEventFilter;

    "AppealDecision(uint256,address)"(
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _arbitrable?: PromiseOrValue<string> | null
    ): AppealDecisionEventFilter;
    AppealDecision(
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _arbitrable?: PromiseOrValue<string> | null
    ): AppealDecisionEventFilter;
  };

  estimateGas: {
    changePinakion(
      _pinakion: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    RNBlock(overrides?: CallOverrides): Promise<BigNumber>;

    disputesWithoutJurors(overrides?: CallOverrides): Promise<BigNumber>;

    passPhase(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    governor(overrides?: CallOverrides): Promise<BigNumber>;

    lastDelayedSetStake(overrides?: CallOverrides): Promise<BigNumber>;

    disputeStatus(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    passPeriod(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    maxDrawingTime(overrides?: CallOverrides): Promise<BigNumber>;

    currentRuling(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    courts(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    execute(
      _disputeID: PromiseOrValue<BigNumberish>,
      _appeal: PromiseOrValue<BigNumberish>,
      _iterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    ALPHA_DIVISOR(overrides?: CallOverrides): Promise<BigNumber>;

    castVote(
      _disputeID: PromiseOrValue<BigNumberish>,
      _voteIDs: PromiseOrValue<BigNumberish>[],
      _choice: PromiseOrValue<BigNumberish>,
      _salt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    changeSubcourtMinStake(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _minStake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getSubcourt(
      _subcourtID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    appeal(
      _disputeID: PromiseOrValue<BigNumberish>,
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    onTransfer(
      _from: PromiseOrValue<string>,
      _to: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    disputes(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    changeSubcourtTimesPerPeriod(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _timesPerPeriod: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    changeSubcourtJurorFee(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _feeForJuror: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    changeSubcourtAlpha(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _alpha: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    castCommit(
      _disputeID: PromiseOrValue<BigNumberish>,
      _voteIDs: PromiseOrValue<BigNumberish>[],
      _commit: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    RN(overrides?: CallOverrides): Promise<BigNumber>;

    RNGenerator(overrides?: CallOverrides): Promise<BigNumber>;

    executeGovernorProposal(
      _destination: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    changeMinStakingTime(
      _minStakingTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    NON_PAYABLE_AMOUNT(overrides?: CallOverrides): Promise<BigNumber>;

    setStake(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _stake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    executeRuling(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getVote(
      _disputeID: PromiseOrValue<BigNumberish>,
      _appeal: PromiseOrValue<BigNumberish>,
      _voteID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    changeRNGenerator(
      _RNGenerator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    executeDelayedSetStakes(
      _iterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakeOf(
      _account: PromiseOrValue<string>,
      _subcourtID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    changeSubcourtJurorsForJump(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _jurorsForCourtJump: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    appealPeriod(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    phase(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_STAKE_PATHS(overrides?: CallOverrides): Promise<BigNumber>;

    delayedSetStakes(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lastPhaseChange(overrides?: CallOverrides): Promise<BigNumber>;

    minStakingTime(overrides?: CallOverrides): Promise<BigNumber>;

    nextDelayedSetStake(overrides?: CallOverrides): Promise<BigNumber>;

    createDispute(
      _numberOfChoices: PromiseOrValue<BigNumberish>,
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    drawJurors(
      _disputeID: PromiseOrValue<BigNumberish>,
      _iterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createSubcourt(
      _parent: PromiseOrValue<BigNumberish>,
      _hiddenVotes: PromiseOrValue<boolean>,
      _minStake: PromiseOrValue<BigNumberish>,
      _alpha: PromiseOrValue<BigNumberish>,
      _feeForJuror: PromiseOrValue<BigNumberish>,
      _jurorsForCourtJump: PromiseOrValue<BigNumberish>,
      _timesPerPeriod: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      _sortitionSumTreeK: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getJuror(
      _account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    onApprove(
      _owner: PromiseOrValue<string>,
      _spender: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    jurors(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    changeMaxDrawingTime(
      _maxDrawingTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getDispute(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getVoteCounter(
      _disputeID: PromiseOrValue<BigNumberish>,
      _appeal: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    changeGovernor(
      _governor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    MIN_JURORS(overrides?: CallOverrides): Promise<BigNumber>;

    appealCost(
      _disputeID: PromiseOrValue<BigNumberish>,
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proxyPayment(
      _owner: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    lockInsolventTransfers(overrides?: CallOverrides): Promise<BigNumber>;

    arbitrationCost(
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    pinakion(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    changePinakion(
      _pinakion: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    RNBlock(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    disputesWithoutJurors(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    passPhase(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    governor(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastDelayedSetStake(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    disputeStatus(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    passPeriod(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    maxDrawingTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    currentRuling(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    courts(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    execute(
      _disputeID: PromiseOrValue<BigNumberish>,
      _appeal: PromiseOrValue<BigNumberish>,
      _iterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    ALPHA_DIVISOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    castVote(
      _disputeID: PromiseOrValue<BigNumberish>,
      _voteIDs: PromiseOrValue<BigNumberish>[],
      _choice: PromiseOrValue<BigNumberish>,
      _salt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    changeSubcourtMinStake(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _minStake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getSubcourt(
      _subcourtID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    appeal(
      _disputeID: PromiseOrValue<BigNumberish>,
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    onTransfer(
      _from: PromiseOrValue<string>,
      _to: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    disputes(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    changeSubcourtTimesPerPeriod(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _timesPerPeriod: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    changeSubcourtJurorFee(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _feeForJuror: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    changeSubcourtAlpha(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _alpha: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    castCommit(
      _disputeID: PromiseOrValue<BigNumberish>,
      _voteIDs: PromiseOrValue<BigNumberish>[],
      _commit: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    RN(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    RNGenerator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    executeGovernorProposal(
      _destination: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    changeMinStakingTime(
      _minStakingTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    NON_PAYABLE_AMOUNT(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setStake(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _stake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    executeRuling(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getVote(
      _disputeID: PromiseOrValue<BigNumberish>,
      _appeal: PromiseOrValue<BigNumberish>,
      _voteID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    changeRNGenerator(
      _RNGenerator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    executeDelayedSetStakes(
      _iterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakeOf(
      _account: PromiseOrValue<string>,
      _subcourtID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    changeSubcourtJurorsForJump(
      _subcourtID: PromiseOrValue<BigNumberish>,
      _jurorsForCourtJump: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    appealPeriod(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    phase(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_STAKE_PATHS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    delayedSetStakes(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastPhaseChange(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minStakingTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextDelayedSetStake(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    createDispute(
      _numberOfChoices: PromiseOrValue<BigNumberish>,
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    drawJurors(
      _disputeID: PromiseOrValue<BigNumberish>,
      _iterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createSubcourt(
      _parent: PromiseOrValue<BigNumberish>,
      _hiddenVotes: PromiseOrValue<boolean>,
      _minStake: PromiseOrValue<BigNumberish>,
      _alpha: PromiseOrValue<BigNumberish>,
      _feeForJuror: PromiseOrValue<BigNumberish>,
      _jurorsForCourtJump: PromiseOrValue<BigNumberish>,
      _timesPerPeriod: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      _sortitionSumTreeK: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getJuror(
      _account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    onApprove(
      _owner: PromiseOrValue<string>,
      _spender: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    jurors(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    changeMaxDrawingTime(
      _maxDrawingTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getDispute(
      _disputeID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVoteCounter(
      _disputeID: PromiseOrValue<BigNumberish>,
      _appeal: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    changeGovernor(
      _governor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    MIN_JURORS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    appealCost(
      _disputeID: PromiseOrValue<BigNumberish>,
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proxyPayment(
      _owner: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    lockInsolventTransfers(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    arbitrationCost(
      _extraData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    pinakion(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
